**This file consists of the entire unaltered output for reference.**

Okay, I've got it. I'm going to take the existing codebase, the project history, the request for Dockerfiles and GitHub Actions, the desire for a green color theme, and the previous code review feedback, and merge it all into a complete, runnable application.

Here's the complete project with all files:

```json
{
  "nft-purchase-app/backend/requirements.txt": "Flask\nFlask-SQLAlchemy\nrequests\npython-dotenv\nsolana\nipfshttpclient\nSQLAlchemy==1.4.41\npsycopg2-binary #Required for postgres",
  "nft-purchase-app/backend/.env": "# backend/.env\nDATABASE_URL=postgresql://user:password@host:port/database_name # Replace this. Could also be a sqlite path\nSOLANA_RPC_URL=https://api.devnet.solana.com # Or your preferred RPC endpoint\nCRAFT_TOKEN_MINT_ADDRESS=YOUR_CRAFT_TOKEN_MINT_ADDRESS # Replace with the actual mint address\nADMIN_WALLET_PRIVATE_KEY=[1,2,3, ... ,255] # replace this. Keep the list formatting.\nADMIN_WALLET_PUBLIC_KEY=YOUR_ADMIN_WALLET_PUBLIC_KEY # Replace this\nIPFS_GATEWAY_URL=https://ipfs.io/ipfs # Or your preferred gateway\nEMAIL_ADDRESS=your_email@gmail.com # Replace\nEMAIL_PASSWORD=your_email_app_password # Replace (use an app password for Gmail)",
  "nft-purchase-app/backend/app.py": "# nft-purchase-app/backend/app.py\nimport os\nimport json  # Import json\nfrom flask import Flask, request, jsonify\nfrom flask_sqlalchemy import SQLAlchemy\nfrom solana.rpc.api import Client\nfrom solana.keypair import Keypair\nfrom solana.transaction import Transaction\nfrom solana.system_program import SystemProgram\nfrom solana.publickey import PublicKey\nfrom dotenv import load_dotenv\nfrom datetime import datetime\nfrom sqlalchemy import event\nfrom sqlalchemy.engine import Engine\nfrom sqlite3 import dbapi2 as sqlite\n\n# Import utility functions\nfrom .utils import generate_nft, send_email\n\nload_dotenv()\n\napp = Flask(__name__)\n\n# Database Configuration\napp.config['SQLALCHEMY_DATABASE_URI'] = os.getenv(\"DATABASE_URL\", 'sqlite:///:memory:')\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\n\n# SQLite foreign key enforcement (for SQLite DBs)\nif \"sqlite\" in app.config['SQLALCHEMY_DATABASE_URI']:\n    @event.listens_for(Engine, \"connect\")\n    def _set_sqlite_pragma(dbapi_connection, connection_record):\n        if isinstance(dbapi_connection, sqlite.Connection):\n            cursor = dbapi_connection.cursor()\n            cursor.execute(\"PRAGMA foreign_keys=ON;\")\n            cursor.close()\n\ndb = SQLAlchemy(app)\n\n# Solana Configuration\nSOLANA_RPC_URL = os.getenv(\"SOLANA_RPC_URL\", \"https://api.devnet.solana.com\")\nCRAFT_TOKEN_MINT_ADDRESS = os.getenv(\"CRAFT_TOKEN_MINT_ADDRESS\")\nADMIN_WALLET_PRIVATE_KEY = os.getenv(\"ADMIN_WALLET_PRIVATE_KEY\")\nADMIN_WALLET_PUBLIC_KEY = os.getenv(\"ADMIN_WALLET_PUBLIC_KEY\")\n\nsolana_client = Client(SOLANA_RPC_URL)\n\n# Load Admin Keypair - Securely (using json.loads instead of eval)\nadmin_keypair = None  # Initialize to None\nif ADMIN_WALLET_PRIVATE_KEY:\n    try:\n        admin_keypair = Keypair.from_secret_key(bytes(json.loads(ADMIN_WALLET_PRIVATE_KEY)))\n    except json.JSONDecodeError as e:\n        print(f\"Error decoding ADMIN_WALLET_PRIVATE_KEY: {e}.  Make sure it's a valid JSON list.\")\n    except Exception as e:\n        print(f\"Error loading admin keypair: {e}\")\n\n    # Validation check.  If admin_keypair did not load from the environment variable, set to None\n    if not admin_keypair:\n        print(\"Admin Keypair could not be loaded.  Admin priviledges unavailable\")\n\nelse:\n    print(\"ADMIN_WALLET_PRIVATE_KEY not set. Admin functions will be disabled.\")\n\n# Database Models\nclass TransactionHistory(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    transaction_id = db.Column(db.String(255), nullable=False, unique=True)\n    user_public_key = db.Column(db.String(255), nullable=False)\n    nft_id = db.Column(db.String(255), db.ForeignKey('nft.nft_id'), nullable=False)\n    timestamp = db.Column(db.DateTime, default=datetime.utcnow)\n\n    def __repr__(self):\n        return f'<Transaction {self.transaction_id}>'\n\n\nclass NFT(db.Model):\n    nft_id = db.Column(db.String(255), primary_key=True)\n    metadata_url = db.Column(db.String(255))\n    owner_public_key = db.Column(db.String(255), nullable=False)\n\n    def __repr__(self):\n        return f'<NFT {self.nft_id}>'\n\n\nwith app.app_context():\n    db.create_all()\n\n\n# Transaction Verification Function\ndef verify_transaction(transaction_signature, user_public_key, amount, craft_token_mint_address, admin_wallet_public_key):\n    try:\n        transaction_data = solana_client.get_transaction(transaction_signature)\n\n        # Robust Error Checking\n        if not transaction_data or transaction_data.get(\"result\") is None or transaction_data[\"result\"].get(\"meta\") is None or transaction_data[\"result\"][\"meta\"].get(\"err\") is not None:\n            return False, \"Transaction failed or not found on Solana\"\n\n        transaction = transaction_data[\"result\"].get(\"transaction\")  # Use .get() for safety\n        if not transaction:\n            return False, \"Transaction data missing\"\n\n        message = transaction.get(\"message\")  # Use .get() for safety\n        if not message:\n            return False, \"Transaction message missing\"\n\n        instructions = message.get(\"instructions\")  # Use .get() for safety\n        if not instructions:\n            return False, \"Transaction instructions missing\"\n\n        transfer_instruction_found = False\n        for instruction in instructions:\n            if not isinstance(instruction, dict):\n                continue  # Skip if instruction is not a dictionary\n\n            accounts = instruction.get(\"accounts\", [])  # Safely get accounts\n            data = instruction.get(\"data\", \"\")  # Safely get data\n\n            program_id_index = instruction.get(\"programIdIndex\")\n            if program_id_index == 2 and len(accounts) >= 3:\n                try:\n                    source_account = message[\"accountKeys\"][accounts[0]]\n                    dest_account = message[\"accountKeys\"][accounts[1]]\n                    token_mint = message[\"accountKeys\"][accounts[2]]\n\n                    if str(token_mint) == craft_token_mint_address and str(source_account) == user_public_key and str(dest_account) == admin_wallet_public_key:\n                        transfer_instruction_found = True\n                        break\n                except (KeyError, IndexError) as e:\n                    print(f\"Error accessing account keys: {e}\")  # Log the specific error with details\n                    return False, f\"Error accessing account keys: {e}\"\n\n        if not transfer_instruction_found:\n            return False, \"Invalid transaction: No transfer to the recipient found.\"\n\n        return True, None\n\n    except Exception as e:\n        print(f\"Error verifying transaction: {e}\")\n        return False, f\"Error during verification: {str(e)}\"\n\n\n# API Endpoint for Payment Verification\n@app.route('/verify_payment', methods=['POST'])\ndef verify_payment():\n    data = request.get_json()\n    if not data:\n        return jsonify({'error': 'Invalid JSON data'}), 400\n\n    transaction_signature = data.get('transactionSignature')\n    user_public_key = data.get('userPublicKey')\n    amount = data.get('amount')  # Amount should be passed as a number in json\n    craft_token_mint_address = data.get('craftTokenMintAddress')\n\n    if not all([transaction_signature, user_public_key, amount, craft_token_mint_address]):\n        return jsonify({'error': 'Missing parameters'}), 400\n\n    try:\n        amount = float(amount)  # Try to convert to float (Defensive programming)\n    except ValueError:\n        return jsonify({'error': 'Invalid amount format'}), 400\n\n    if not admin_keypair:\n        return jsonify({'success': False, 'error': 'Admin wallet not properly configured'}), 500\n\n    is_valid, error_message = verify_transaction(transaction_signature, user_public_key, amount, craft_token_mint_address, ADMIN_WALLET_PUBLIC_KEY)\n\n    if is_valid:\n        nft_data = generate_nft(user_public_key)\n        if not nft_data:\n            return jsonify({'success': False, 'error': 'NFT generation failed'}), 500\n\n        nft = NFT(nft_id=nft_data['nft_id'], metadata_url=nft_data.get('metadata_url', ''), owner_public_key=user_public_key)\n        new_transaction = TransactionHistory(transaction_id=transaction_signature, user_public_key=user_public_key, nft_id=nft.nft_id)\n\n        try:\n            db.session.add(nft)\n            db.session.add(new_transaction)\n            db.session.commit()\n        except Exception as e:\n            db.session.rollback()\n            return jsonify({'success': False, 'error': f'Database error: {str(e)}'}), 500\n\n        email_html = f\"\"\"\n            <html>\n            <body>\n                <p>Congratulations! You've purchased an NFT!</p>\n                <img src="{nft_data['image']}" alt="Your NFT">\n                <p>Download your NFT: <a href="{nft_data['image']}">Download SVG</a></p>\n            </body>\n            </html>\n        \"\"\"\n        send_email(user_public_key, \"Your New NFT!\", \"See the attached NFT!\", html=email_html)\n\n        return jsonify({'success': True, 'message': 'Payment verified, NFT generated and email sent!', 'nft_data': nft_data})\n    else:\n        return jsonify({'success': False, 'error': error_message}), 400\n\n\n# API Endpoint to Retrieve NFTs for a User\n@app.route('/get_nfts/<user_public_key>', methods=['GET'])\ndef get_nfts(user_public_key):\n    \"\"\"Retrieves all NFTs associated with a user's public key.\"\"\"\n    nfts = NFT.query.filter_by(owner_public_key=user_public_key).all()\n    nft_data = []\n    for nft in nfts:\n        nft_data.append({\n            'nft_id': nft.nft_id,\n            'metadata_url': nft.metadata_url,\n        })\n    return jsonify(nft_data)\n\n\nif __name__ == '__main__':\n    app.run(debug=True)",
  "nft-purchase-app/backend/utils.py": "# nft-purchase-app/backend/utils.py\nimport os\nimport svgwrite\nimport json\nimport hashlib\nimport secrets\nimport time\nimport base64\nfrom dotenv import load_dotenv\nfrom ipfshttpclient import connect\nimport smtplib\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\n\nload_dotenv()\n\nIPFS_GATEWAY_URL = os.getenv(\"IPFS_GATEWAY_URL\")\nEMAIL_ADDRESS = os.getenv(\"EMAIL_ADDRESS\")\nEMAIL_PASSWORD = os.getenv(\"EMAIL_PASSWORD\")\n\ndef generate_unique_id():\n    timestamp = str(int(time.time()))\n    random_token = secrets.token_hex(16)\n    combined_string = timestamp + random_token\n    unique_id = hashlib.sha256(combined_string.encode()).hexdigest()\n    return unique_id\n\ndef generate_svg(unique_identifier):\n    dwg = svgwrite.Drawing('temp.svg', profile='tiny')\n    x = int(unique_identifier[:2], 16) * 5\n    y = int(unique_identifier[2:4], 16) * 5\n    radius = int(unique_identifier[4:6], 16) / 8\n    color = f\"#{unique_identifier[6:12]}\"\n\n    dwg.add(dwg.circle((x, y), radius, fill=color))\n    dwg.save()\n    return 'temp.svg'\n\ndef upload_to_ipfs(file_path):\n    try:\n        client = connect()\n        with open(file_path, 'rb') as f:\n            response = client.add(f)\n            return response['Hash']\n    except Exception as e:\n        print(f\"Error uploading to IPFS: {e}\")\n        return None\n\ndef generate_nft(user_public_key):\n    unique_id = generate_unique_id()\n    svg_file = generate_svg(unique_id)\n\n    image_cid = upload_to_ipfs(svg_file)\n    if image_cid is None:\n        return None\n\n    metadata = {\n        \"name\": f\"My Cool NFT - {unique_id[:8]}\",\n        \"description\": \"A Unique NFT Generated for User\",\n        \"image\": f\"{IPFS_GATEWAY_URL}/{image_cid}\",\n        \"attributes\": [\n            {\"trait_type\": \"Generated For\", \"value\": user_public_key},\n            {\"trait_type\": \"Unique ID\", \"value\": unique_id}\n        ],\n        \"nft_id\": unique_id\n    }\n\n    metadata_json = json.dumps(metadata, indent=4).encode('utf-8')\n\n    metadata_cid = upload_to_ipfs(metadata_json)\n    if metadata_cid:\n        metadata[\"metadata_url\"] = f\"{IPFS_GATEWAY_URL}/{metadata_cid}\"\n    else:\n        print(\"Warning: Could not upload metadata to IPFS\")\n\n    os.remove(svg_file)\n\n    return metadata\n\ndef send_email(recipient, subject, body, html=None, image_path=None):\n    if not EMAIL_ADDRESS or not EMAIL_PASSWORD:\n        print(\"Email credentials not set. Cannot send email.\")\n        return False\n\n    msg = MIMEMultipart('alternative')\n    msg['From'] = EMAIL_ADDRESS\n    msg['To'] = recipient\n    msg['Subject'] = subject\n\n    msg.attach(MIMEText(body, 'plain'))\n\n    if html:\n        if image_path:\n            try:\n                with open(image_path, 'rb') as img_file:\n                    img_data = img_file.read()\n                    img_base64 = base64.b64encode(img_data).decode('utf-8')\n                    html = html.replace('cid:image1', f'data:image/svg+xml;base64,{img_base64}')\n            except Exception as e:\n                print(f\"Error embedding image: {e}\")\n\n        msg.attach(MIMEText(html, 'html'))\n\n    try:\n        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as server:\n            server.login(EMAIL_ADDRESS, EMAIL_PASSWORD)\n            server.sendmail(EMAIL_ADDRESS, recipient, msg.as_string())\n        print(\"Email sent successfully!\")\n        return True\n    except Exception as e:\n        print(f\"Email sending failed: {e}\")\n        return False",
  "nft-purchase-app/backend/models.py": "# backend/models.py\nfrom app import db\nfrom datetime import datetime\n\nclass TransactionHistory(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    transaction_id = db.Column(db.String(255), nullable=False, unique=True)\n    user_public_key = db.Column(db.String(255), nullable=False)\n    nft_id = db.Column(db.String(255), db.ForeignKey('nft.nft_id'), nullable=False)\n    timestamp = db.Column(db.DateTime, default=datetime.utcnow)\n\n    def __repr__(self):\n        return f'<Transaction {self.transaction_id}>'\n\n\nclass NFT(db.Model):\n    nft_id = db.Column(db.String(255), primary_key=True)\n    metadata_url = db.Column(db.String(255))\n    owner_public_key = db.Column(db.String(255), nullable=False)\n\n    def __repr__(self):\n        return f'<NFT {self.nft_id}>'",
  "nft-purchase-app/backend/tests/__init__.py": "# backend/tests/__init__.py\n#Empty file.",
  "nft-purchase-app/backend/tests/test_utils.py": "# backend/tests/test_utils.py\nimport pytest\nfrom unittest.mock import patch\n\nfrom backend.utils import generate_svg, upload_to_ipfs, send_email\nimport os\n\ndef test_generate_svg():\n    svg_file = generate_svg(\"test_hash\")\n    assert os.path.exists(svg_file)\n    os.remove(svg_file)\n\n\n@patch('backend.utils.connect')\ndef test_upload_to_ipfs(mock_connect):\n    mock_instance = mock_connect.return_value\n    mock_instance.add.return_value = {'Hash': 'test_cid'}\n    cid = upload_to_ipfs(\"dummy_file.txt\")\n    assert cid == \"test_cid\"\n\n\ndef test_send_email():\n    result = send_email(\"test@example.com\", \"Test Subject\", \"Test Body\")\n    assert result is False",
  "nft-purchase-app/frontend/src/App.js": "// frontend/src/App.js\nimport React, { useState } from 'react';\nimport WalletConnect from './components/WalletConnect';\nimport NFTDisplay from './components/NFTDisplay';\nimport PurchaseButton from './components/PurchaseButton'; // Import the PurchaseButton\nimport './App.css';\n\nfunction App() {\n    // Configuration - Replace these with your actual values.\n    const nftPrice = 100; // Price of the NFT in CRAFT tokens\n    const craftTokenMintAddress = \"YOUR_CRAFT_TOKEN_MINT_ADDRESS\"; // Token Mint\n    const craftTokenDecimals = 9; // Token Decimals\n\n    const [purchasedNft, setPurchasedNft] = useState(null);\n\n    const handlePurchaseSuccess = (nftData) => {\n        setPurchasedNft(nftData);\n    };\n\n    return (\n        <div className=\"App\">\n            <header className=\"App-header\">\n                <h1 style={{ color: 'forestgreen' }}>NFT Purchase App</h1> {/* Added green color */}\n                <WalletConnect />\n\n                {/* Render PurchaseButton */}\n                <PurchaseButton\n                    amount={nftPrice}\n                    craftTokenMintAddress={craftTokenMintAddress}\n                    decimals={craftTokenDecimals}\n                    onPurchaseSuccess={handlePurchaseSuccess}\n                />\n\n                {/* Conditionally render NFTDisplay */}\n                {purchasedNft ? (\n                    <>\n                        <h2 style={{ color: 'forestgreen' }}>Congratulations on your purchase!</h2>{/* Added green color */}\n                        <NFTDisplay nft={purchasedNft} />\n                    </>\n                ) : (\n                    <NFTDisplay />\n                )}\n            </header>\n        </div>\n    );\n}\n\nexport default App;",
  "nft-purchase-app/frontend/src/components/WalletConnect.js": "// frontend/src/components/WalletConnect.js\nimport React, { useCallback, useMemo } from 'react';\nimport {\n    ConnectionProvider,\n    WalletProvider,\n} from '@solana/wallet-adapter-react';\nimport { WalletAdapterNetwork } from '@solana/wallet-adapter-base';\nimport {\n    PhantomWalletAdapter,\n    SolflareWalletAdapter\n} from '@solana/wallet-adapter-wallets';\nimport {\n    WalletModalProvider,\n    WalletDisconnectButton,\n    WalletMultiButton\n} from '@solana/wallet-adapter-react-ui';\nimport { clusterApiUrl } from '@solana/web3.js';\n\n// Default styles that can be overridden by your app\nrequire('@solana/wallet-adapter-react-ui/styles.css');\n\nconst WalletConnect = () => {\n    const network = WalletAdapterNetwork.Devnet;\n    const endpoint = useMemo(() => clusterApiUrl(network), [network]);\n\n    const wallets = useMemo(() => [\n        new PhantomWalletAdapter(),\n        new SolflareWalletAdapter({ network }),\n    ], [network]);\n\n    return (\n        <ConnectionProvider endpoint={endpoint}>\n            <WalletProvider wallets={wallets} autoConnect>\n                <WalletModalProvider>\n                    <WalletMultiButton />\n                    <WalletDisconnectButton />\n                </WalletModalProvider>\n            </WalletProvider>\n        </ConnectionProvider>\n    );\n};\n\nexport default WalletConnect;",
  "nft-purchase-app/frontend/src/components/NFTDisplay.js": "// frontend/src/components/NFTDisplay.js\nimport React, { useState, useEffect } from 'react';\nimport axios from 'axios';\nimport { useWallet } from '@solana/wallet-adapter-react';\n\nconst NFTDisplay = ({ nft }) => {  // Now it receives an `nft` prop\n    const { publicKey } = useWallet();\n    const [nfts, setNfts] = useState([]);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() => {\n        const fetchNFTs = async () => {\n            if (publicKey) {\n                try {\n                    // Make sure to replace with your actual backend URL\n                    const response = await axios.get(`/get_nfts/${publicKey.toString()}`);\n                    setNfts(response.data);\n                    setError(null);\n                } catch (err) {\n                    console.error(\"Error fetching NFTs:\", err);\n                    setError(err.message || \"Failed to fetch NFTs\");\n                    setNfts([]);\n                } finally {\n                    setLoading(false);\n                }\n            } else {\n                setLoading(false);\n                setNfts([]);\n                setError(null);\n            }\n        };\n\n        // If an NFT is passed as a prop, display it directly\n        if (nft) {\n            setNfts([nft]); // Display the passed NFT\n            setLoading(false);\n        } else {\n            // Otherwise, fetch NFTs from the backend (usual behavior)\n            fetchNFTs();\n        }\n    }, [publicKey, nft]); // Reacts to changes in `publicKey` or `nft`\n\n    if (loading) {\n        return <div>Loading NFTs...</div>;\n    }\n\n    if (error) {\n        return <div style={{ color: 'red' }}>Error: {error}</div>;\n    }\n\n    if (!publicKey) {\n        return <div>Connect your wallet to view your NFTs.</div>;\n    }\n\n    return (\n        <div>\n            <h2 style={{ color: 'forestgreen' }}>Your NFTs</h2> {/* Added green color */}\n            {nfts.length === 0 ? (\n                <div>No NFTs found in your wallet.</div>\n            ) : (\n                <ul>\n                    {nfts.map((nft) => (\n                        <li key={nft.nft_id}>\n                            <h3 style={{ color: 'forestgreen' }}>{nft.metadata_url ? 'NFT Metadata' : 'Missing Metadata'}</h3> {/* Added green color */}\n                            {nft.metadata_url ? (\n                                <a href={nft.metadata_url} target=\"_blank\" rel=\"noopener noreferrer\">\n                                    View NFT Metadata\n                                </a>\n                            ) : (\n                                <p>Metadata not available.</p>\n                            )}\n                            {nft.image && <img src={nft.image} alt=\"NFT\" width=\"100\" />} {/* Display the image */}\n                        </li>\n                    ))}\n                </ul>\n            )}\n        </div>\n    );\n};\n\nexport default NFTDisplay;",
  "nft-purchase-app/frontend/src/components/PurchaseButton.js": "// frontend/src/components/PurchaseButton.js\nimport React, { useState } from 'react';\nimport { useWallet } from '@solana/wallet-adapter-react';\nimport { PublicKey, Transaction } from '@solana/web3.js';\nimport axios from 'axios';\nimport { connection } from '../utils/solana';\nimport { TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID, getOrCreateAssociatedTokenAccount, createTransferInstruction } from '@solana/spl-token';\n\nconst PurchaseButton = ({ amount, craftTokenMintAddress, decimals, onPurchaseSuccess }) => {\n    const { publicKey, sendTransaction } = useWallet();\n    const [isPurchasing, setIsPurchasing] = useState(false);\n    const [errorMessage, setErrorMessage] = useState(null);\n\n    // Replace with the actual recipient (e.g., the program's) public key\n    const recipientPublicKey = \"YOUR_RECIPIENT_PUBLIC_KEY\";\n\n\n    const handlePurchase = async () => {\n        setIsPurchasing(true);\n        setErrorMessage(null);\n\n        if (!publicKey) {\n            setErrorMessage(\"Wallet not connected.\");\n            setIsPurchasing(false);\n            return;\n        }\n\n        if (recipientPublicKey === \"YOUR_RECIPIENT_PUBLIC_KEY\") {\n            setErrorMessage(\"RECIPIENT Public Key not Configured on frontend/src/components/PurchaseButton.js\");\n            setIsPurchasing(false);\n            return;\n        }\n\n        if (craftTokenMintAddress === \"YOUR_CRAFT_TOKEN_MINT_ADDRESS\") {\n            setErrorMessage(\"CRAFT TOKEN MINT ADDRESS not Configured properly on frontend/src/App.js.\");\n            setIsPurchasing(false);\n            return;\n        }\n\n\n        try {\n            // Get the purchaser's associated token account\n            const purchaserAssociatedTokenAccount = await getOrCreateAssociatedTokenAccount(\n                connection,\n                publicKey,\n                new PublicKey(craftTokenMintAddress),\n                publicKey\n            );\n\n            // Get the recipient's associated token account\n            const recipientAssociatedTokenAccount = await getOrCreateAssociatedTokenAccount(\n                connection,\n                publicKey,\n                new PublicKey(craftTokenMintAddress),\n                new PublicKey(recipientPublicKey)  // Recipient Public Key\n            );\n\n\n            // Convert amount to token units\n            const amountInTokenUnits = amount * (10 ** decimals);\n\n            // Build the transfer instruction\n            const transferInstruction = createTransferInstruction(\n                purchaserAssociatedTokenAccount.address,\n                recipientAssociatedTokenAccount.address,\n                publicKey,\n                amountInTokenUnits,\n                [],\n                TOKEN_PROGRAM_ID\n            );\n\n            // Create and send the transaction\n            const transaction = new Transaction().add(transferInstruction);\n            transaction.feePayer = publicKey;\n            transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n\n            const signature = await sendTransaction(transaction, connection);\n\n            // Verify the transaction on the backend\n            const response = await axios.post('/verify_payment', {\n                transactionSignature: signature,\n                userPublicKey: publicKey.toString(),\n                amount: amount,\n                craftTokenMintAddress: craftTokenMintAddress\n            });\n\n            if (response.data.success) {\n                // If payment is successful, call the onPurchaseSuccess callback\n                onPurchaseSuccess(response.data.nft_data);\n            } else {\n                setErrorMessage(response.data.error || \"Payment verification failed.\");\n            }\n\n        } catch (error) {\n            console.error(\"Purchase error:\", error);\n            setErrorMessage(error.message || \"An error occurred during purchase.\");\n        } finally {\n            setIsPurchasing(false);\n        }\n    };\n\n    return (\n        <div>\n            <button onClick={handlePurchase} disabled={isPurchasing}\n                style={{ backgroundColor: 'forestgreen', color: 'white', padding: '10px 15px', borderRadius: '5px', border: 'none', cursor: 'pointer' }}\n            >\n                {isPurchasing ? \"Purchasing...\" : `Purchase NFT (${amount} CRAFT)`}\n            </button>\n            {errorMessage && <div style={{ color: 'red' }}>Error: {errorMessage}</div>}\n        </div>\n    );\
