**This file consists of the entire unaltered output for reference.**

Okay, I've taken all of your previous prompts, the project plan, the existing code structure, the code review feedback (which was a sample; I will treat it as representative), and your new request for Dockerfiles and GitHub Actions deployment into account. I will now generate the complete, fully functional code with explanations, focusing on satisfying your requirements without making unnecessary changes.

Here's the plan:

1.  **Address Code Review:** I'll implement the security and error handling improvements suggested in the sample code review.
2.  **Dockerfiles:** I will create `Dockerfile`s for both the backend and the frontend. These will be simple, production-ready files that allow you to containerize your application.
3.  **GitHub Actions:** I will create a `.github/workflows` directory and a basic workflow file to build and deploy your application. I'll provide comments in the workflow file to guide you through the specifics of configuring your deployment.

Here is the updated code, with explanations and caveats.

```json
{
  "nft-purchase-app/backend/requirements.txt": "Flask\nFlask-SQLAlchemy\nrequests\npython-dotenv\nsolana\nipfshttpclient\nSQLAlchemy==1.4.41\npsycopg2-binary #Required for postgres",
  "nft-purchase-app/backend/.env": "# backend/.env\nDATABASE_URL=postgresql://user:password@host:port/database_name # Replace this. Could also be a sqlite path\nSOLANA_RPC_URL=https://api.devnet.solana.com # Or your preferred RPC endpoint\nCRAFT_TOKEN_MINT_ADDRESS=YOUR_CRAFT_TOKEN_MINT_ADDRESS # Replace with the actual mint address\nADMIN_WALLET_PRIVATE_KEY=[1,2,3, ... ,255] # replace this. Keep the list formatting.\nADMIN_WALLET_PUBLIC_KEY=YOUR_ADMIN_WALLET_PUBLIC_KEY # Replace this\nIPFS_GATEWAY_URL=https://ipfs.io/ipfs # Or your preferred gateway\nEMAIL_ADDRESS=your_email@gmail.com # Replace\nEMAIL_PASSWORD=your_email_app_password # Replace (use an app password for Gmail)",
  "nft-purchase-app/backend/app.py": "# nft-purchase-app/backend/app.py\nimport os\nfrom flask import Flask, request, jsonify\nfrom flask_sqlalchemy import SQLAlchemy\nfrom solana.rpc.api import Client\nfrom solana.keypair import Keypair\nfrom solana.transaction import Transaction\nfrom solana.system_program import SystemProgram\nfrom solana.publickey import PublicKey\nfrom dotenv import load_dotenv\nfrom datetime import datetime  # Import datetime\nfrom sqlalchemy import event\nfrom sqlalchemy.engine import Engine\nfrom sqlite3 import dbapi2 as sqlite\nimport json # Import the json module\n\n# Import utility functions (NFT generation, email, etc.)\nfrom .utils import generate_nft, send_email\n\nload_dotenv()\n\napp = Flask(__name__)\n\n# Database Configuration\napp.config[\'SQLALCHEMY_DATABASE_URI\'] = os.getenv(\"DATABASE_URL\", \'sqlite:///:memory:\')  # Replace with your DB URL\napp.config[\'SQLALCHEMY_TRACK_MODIFICATIONS\'] = False\n\nif \"sqlite\" in app.config[\'SQLALCHEMY_DATABASE_URI\']:\n    @event.listens_for(Engine, \"connect\")\n    def _set_sqlite_pragma(dbapi_connection, connection_record):\n        if isinstance(dbapi_connection, sqlite.Connection):\n            cursor = dbapi_connection.cursor()\n            cursor.execute(\"PRAGMA foreign_keys=ON;\")\n            cursor.close()\n\ndb = SQLAlchemy(app)\n\n# Solana Configuration\nSOLANA_RPC_URL = os.getenv(\"SOLANA_RPC_URL\", \"https://api.devnet.solana.com\")  # Default to devnet\nCRAFT_TOKEN_MINT_ADDRESS = os.getenv(\"CRAFT_TOKEN_MINT_ADDRESS\")\nADMIN_WALLET_PRIVATE_KEY = os.getenv(\"ADMIN_WALLET_PRIVATE_KEY\")  # Securely manage this!\nADMIN_WALLET_PUBLIC_KEY = os.getenv(\"ADMIN_WALLET_PUBLIC_KEY\")\n\nsolana_client = Client(SOLANA_RPC_URL)\n\n\n# Ensure  ADMIN_WALLET_PRIVATE_KEY is not None before attempting to use it.\nif ADMIN_WALLET_PRIVATE_KEY:\n    try:\n        # Load the private key from the environment variable.  It MUST be a valid JSON list.\n        admin_keypair = Keypair.from_secret_key(bytes(json.loads(ADMIN_WALLET_PRIVATE_KEY)))  # Load from JSON\n    except Exception as e:\n        print(f\"Error loading admin keypair: {e}\")\n        admin_keypair = None # Set to None to prevent further errors\n\nelse:\n    admin_keypair = None\n    print(\"ADMIN_WALLET_PRIVATE_KEY not set.  Application will not be\"  \n          \"able to perform admin functions.\")\n\n# Database Models\nclass TransactionHistory(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    transaction_id = db.Column(db.String(255), nullable=False, unique=True)\n    user_public_key = db.Column(db.String(255), nullable=False)\n    nft_id = db.Column(db.String(255), db.ForeignKey(\'nft.nft_id\'), nullable=False)  # Foreign key to NFT\n    timestamp = db.Column(db.DateTime, default=datetime.utcnow)\n\n    def __repr__(self):\n        return f\"<Transaction {self.transaction_id}>\"\n\n\nclass NFT(db.Model):\n    nft_id = db.Column(db.String(255), primary_key=True)  # Use String for NFT IDs\n    metadata_url = db.Column(db.String(255))  # IPFS URL for the metadata\n    owner_public_key = db.Column(db.String(255), nullable=False)\n\n    def __repr__(self):\n        return f\"<NFT {self.nft_id}>\"\n\n\nwith app.app_context():\n    db.create_all()  # Create tables\n\n\n# Improved Transaction Verification Function\ndef verify_transaction(transaction_signature, user_public_key, amount, craft_token_mint_address, admin_wallet_public_key):\n\n    try:\n        transaction_data = solana_client.get_transaction(transaction_signature)\n\n        if not transaction_data or transaction_data[\"result\"] is None or transaction_data[\"result\"][\"meta\"][\"err\"] is not None:\n            return False, \"Transaction failed or not found on Solana\"\n\n        transaction = transaction_data[\"result\"][\"transaction\"]\n        message = transaction[\"message\"]\n        instructions = message[\"instructions\"]\n\n        # Check if the transaction involves a transfer FROM the user TO the admin (or designated recipient)\n        transfer_instruction_found = False\n        for instruction in instructions:\n            # Safer access to instruction data\n            if not isinstance(instruction, dict):\n                continue #Skip if instruction is not a dictionary.\n\n            accounts = instruction.get(\"accounts\", []) #Safely get accounts\n            data = instruction.get(\"data\", \"\") #Added Safety check for 'data'\n\n            # Decode instruction data (Spl Token Program)\n            program_id_index = instruction.get(\"programIdIndex\")\n            if program_id_index == 2 and len(accounts) >= 3: #SPL Token transfer has at least 3 accounts\n                 source_account = message[\"accountKeys\"][accounts[0]]\n                 dest_account   = message[\"accountKeys\"][accounts[1]]\n                 token_mint     = message[\"accountKeys\"][accounts[2]]\n\n                 #Verify correct token mint address, source, and destination\n                 if str(token_mint) == craft_token_mint_address and str(source_account) == user_public_key and str(dest_account) ==  admin_wallet_public_key:\n                    transfer_instruction_found = True #Suitable transfer found\n                    break #Exit loop\n\n        if not transfer_instruction_found:\n            return False, \"Invalid transaction: No transfer to the recipient found.\"\n        return True, None  # Transaction is valid\n\n    except Exception as e:\n        print(f\"Error verifying transaction: {e}\") # Good to keep for debugging\n        return False, f\"Error during verification: {str(e)}\"\n\n\n# API Endpoint for Payment Verification\n@app.route(\'/verify_payment\', methods=[\'POST\'])\ndef verify_payment():\n    data = request.get_json()\n    transaction_signature = data.get(\'transactionSignature\')\n    user_public_key = data.get(\'userPublicKey\')\n    amount = float(data.get(\'amount\'))  # Amount of CRAFT tokens\n    craft_token_mint_address = data.get(\'craftTokenMintAddress\')\n\n    if not all([transaction_signature, user_public_key, amount, craft_token_mint_address]):\n        return jsonify({\'error\': \'Missing parameters\'}), 400\n\n\n    # Validate that the Admin keypair is properly loaded before transacting with it.\n    if not admin_keypair:\n        return jsonify({\'success\': False, \'error\': \'Admin wallet not properly configured\'}), 500\n\n    is_valid, error_message = verify_transaction(transaction_signature, user_public_key, amount, craft_token_mint_address, ADMIN_WALLET_PUBLIC_KEY)\n\n    if is_valid:\n        # Generate NFT (call your function)\n        nft_data = generate_nft(user_public_key)  # This should return the NFT metadata\n\n        if not nft_data:\n             return jsonify({\'success\': False, \'error\': \'NFT generation failed\'}), 500\n\n        # Store NFT in database\n        nft = NFT(nft_id=nft_data[\'nft_id\'], metadata_url=nft_data.get(\'metadata_url\', \'\'), owner_public_key=user_public_key)\n\n        # Store transaction ONLY after NFT is successfully created/stored\n        new_transaction = TransactionHistory(transaction_id=transaction_signature, user_public_key=user_public_key, nft_id=nft.nft_id)\n\n\n        try:\n            db.session.add(nft) #Add NFT First\n            db.session.add(new_transaction)\n            db.session.commit()\n        except Exception as e:\n            db.session.rollback() #Rollback upon error\n            return jsonify({\'success\': False, \'error\': f\'Database error: {str(e)}\'}), 500\n\n        # Send email (call your email function)\n        email_html = f\"\"\"\n            <html>\n            <body>\n                <p>Congratulations! You've purchased an NFT!</p>\n                <img src="{nft_data['image']}" alt="Your NFT">\n                <p>Download your NFT: <a href="{nft_data['image']}">Download SVG</a></p>\n            </body>\n            </html>\n        \"\"\"\n        send_email(user_public_key, \"Your New NFT!\", \"See the attached NFT!\", html=email_html)\n\n\n        return jsonify({\'success\': True, \'message\': \'Payment verified, NFT generated and email sent!\', \'nft_data\': nft_data})\n    else:\n        return jsonify({\'success\': False, \'error\': error_message}), 400\n\n\n# API Endpoint to Retrieve NFTs for a User\n@app.route(\'/get_nfts/<user_public_key>\', methods=[\'GET\'])\ndef get_nfts(user_public_key):\n    \"\"\"Retrieves all NFTs associated with a user\'s public key.\"\"\"\n    nfts = NFT.query.filter_by(owner_public_key=user_public_key).all() #Query based on owner\n\n    nft_data = []\n    for nft in nfts:\n        nft_data.append({\n            \'nft_id\': nft.nft_id,\n            \'metadata_url\': nft.metadata_url, #Return Metadata URL\n        })\n    return jsonify(nft_data)\n\n\nif __name__ == \'__main__\':\n    app.run(debug=True)",
  "nft-purchase-app/backend/utils.py": "# nft-purchase-app/backend/utils.py\nimport os\nimport svgwrite\nimport json\nimport hashlib\nimport secrets\nimport time # Import time\nfrom dotenv import load_dotenv\nfrom ipfshttpclient import connect\nimport smtplib\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\nimport base64\n\nload_dotenv()\n\nIPFS_GATEWAY_URL = os.getenv(\"IPFS_GATEWAY_URL\")\nEMAIL_ADDRESS = os.getenv(\"EMAIL_ADDRESS\")\nEMAIL_PASSWORD = os.getenv(\"EMAIL_PASSWORD\")\n\ndef generate_unique_id():\n    \"\"\"Generates a unique identifier using a combination of timestamp and random token.\"\"\"\n    timestamp = str(int(time.time()))  # Current timestamp as a string\n    random_token = secrets.token_hex(16)  # 16 bytes of random data (32 hex characters)\n    combined_string = timestamp + random_token\n    unique_id = hashlib.sha256(combined_string.encode()).hexdigest()\n    return unique_id\n\ndef generate_svg(unique_identifier):\n    \"\"\"Generates a simple SVG image based on a unique identifier.\"\"\"\n    dwg = svgwrite.Drawing(\'temp.svg\', profile=\'tiny\')\n    # Use the hash to determine the circle\'s color and position.\n    x = int(unique_identifier[:2], 16) * 5  # First two characters for X position\n    y = int(unique_identifier[2:4], 16) * 5  # Next two for Y position\n    radius = int(unique_identifier[4:6], 16) / 8  # Next two for radius\n    color = f\"#{unique_identifier[6:12]}\"  # Next six for color\n\n    dwg.add(dwg.circle((x, y), radius, fill=color))\n    dwg.save()\n    return \'temp.svg\'\n\ndef upload_to_ipfs(file_path):\n    \"\"\"Uploads a file to IPFS and returns the CID.\"\"\"\n    try:\n        client = connect() #Connects to local\n        with open(file_path, \'rb\') as f:\n            response = client.add(f)\n            return response[\'Hash\']\n    except Exception as e:\n        print(f\"Error uploading to IPFS: {e}\")\n        return None\n\ndef generate_nft(user_public_key):\n    \"\"\"Generates a unique NFT, uploads it to IPFS, and returns the metadata.\"\"\"\n    unique_id = generate_unique_id()\n    svg_file = generate_svg(unique_id)\n\n    #Upload to IPFS\n    image_cid = upload_to_ipfs(svg_file)\n    if image_cid is None:\n        return None\n\n    #Construct metadata\n    metadata = {\n        \"name\": f\"My Cool NFT - {unique_id[:8]}\",  #Shortened ID\n        \"description\": \"A Unique NFT Generated for User\",\n        \"image\": f\"{IPFS_GATEWAY_URL}/{image_cid}\",  #IPFS Gateway\n        \"attributes\": [\n            {\"trait_type\": \"Generated For\", \"value\": user_public_key},\n            {\"trait_type\": \"Unique ID\", \"value\": unique_id}\n        ],\n        \"nft_id\": unique_id #Good to store unique IDs for retrieval later in the database\n    }\n\n    #Optionally Upload Metadata to IPFS - Recommended\n    metadata_json = json.dumps(metadata, indent=4).encode(\'utf-8\') #Properly format JSON\n\n    metadata_cid = upload_to_ipfs(metadata_json) #UTF-8 Encoding!\n    if metadata_cid:\n       metadata[\"metadata_url\"] = f\"{IPFS_GATEWAY_URL}/{metadata_cid}\" #Store this in database\n    else:\n        print(\"Warning: Could not upload metadata to IPFS\")\n\n\n    #Clean up temporary SVG file\n    os.remove(svg_file)\n\n    return metadata\n\ndef send_email(recipient, subject, body, html=None, image_path=None):\n    \"\"\"Sends an email using SMTP.\"\"\"\n\n    if not EMAIL_ADDRESS or not EMAIL_PASSWORD:\n        print(\"Email credentials not set.  Cannot send email.\")\n        return False #Indicate failure\n\n    msg = MIMEMultipart(\'alternative\')\n    msg[\'From\'] = EMAIL_ADDRESS\n    msg[\'To\'] = recipient\n    msg[\'Subject\'] = subject\n\n    msg.attach(MIMEText(body, \'plain\'))\n\n    if html:\n        # If an image path is provided, embed the image in the HTML\n        if image_path:\n            try:\n                with open(image_path, \'rb\') as img_file:\n                    img_data = img_file.read()\n                    img_base64 = base64.b64encode(img_data).decode(\'utf-8\')\n                    html = html.replace(\'cid:image1\', f\'data:image/svg+xml;base64,{img_base64}\') #Reference Image\n            except Exception as e:\n                print(f\"Error embedding image: {e}\")\n\n        msg.attach(MIMEText(html, \'html\'))\n\n\n    try:\n        with smtplib.SMTP_SSL(\'smtp.gmail.com\', 465) as server: #Adjust for your provider\n            server.login(EMAIL_ADDRESS, EMAIL_PASSWORD)\n            server.sendmail(EMAIL_ADDRESS, recipient, msg.as_string())\n        print(\"Email sent successfully!\")\n        return True  #Indicate Success\n\n    except Exception as e:\n        print(f\"Email sending failed: {e}\")\n        return False  #Indicate Failure",
  "nft-purchase-app/backend/models.py": "# backend/models.py\nfrom app import db #Import db from app.py\nfrom datetime import datetime\n\nclass TransactionHistory(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    transaction_id = db.Column(db.String(255), nullable=False, unique=True)\n    user_public_key = db.Column(db.String(255), nullable=False)\n    nft_id = db.Column(db.String(255), db.ForeignKey(\'nft.nft_id\'), nullable=False)  # Foreign key to NFT\n    timestamp = db.Column(db.DateTime, default=datetime.utcnow)\n\n    def __repr__(self):\n        return f\"<Transaction {self.transaction_id}>\"\n\n\nclass NFT(db.Model):\n    nft_id = db.Column(db.String(255), primary_key=True)  # Use String for NFT IDs\n    metadata_url = db.Column(db.String(255))  # IPFS URL for the metadata\n    owner_public_key = db.Column(db.String(255), nullable=False)\n\n    def __repr__(self):\n        return f\"<NFT {self.nft_id}>\"",
  "nft-purchase-app/backend/tests/__init__.py": "# backend/tests/__init__.py\n#Empty file.  Makes the directory a package.",
  "nft-purchase-app/backend/tests/test_utils.py": "# backend/tests/test_utils.py\nimport pytest\nfrom backend.utils import generate_svg, upload_to_ipfs, send_email\nimport os\n\ndef test_generate_svg():\n    svg_file = generate_svg(\"test_hash\")\n    assert os.path.exists(svg_file)\n    os.remove(svg_file) #Clean up\n\n#Mocking IPFS for testing\nfrom unittest.mock import patch\n@patch(\'backend.utils.connect\')\ndef test_upload_to_ipfs(mock_connect):\n    mock_instance = mock_connect.return_value\n    mock_instance.add.return_value = {\'Hash\': \'test_cid\'}\n    cid = upload_to_ipfs(\"dummy_file.txt\")\n    assert cid == \"test_cid\"\n\n#Test Email Sending\ndef test_send_email():\n    #This test will only verify that the function runs without errors,\n    #not that the email is actually sent (due to credentials).\n    #You can extend it to check the return value based on successful/failed login\n\n    result = send_email(\"test@example.com\", \"Test Subject\", \"Test Body\")\n    assert result is False #Because email is not configured properly",
  "nft-purchase-app/frontend/src/App.js": "// frontend/src/App.js\nimport React from 'react';\nimport WalletConnect from './components/WalletConnect';\nimport NFTDisplay from './components/NFTDisplay';\nimport PurchaseButton from './components/PurchaseButton'; // Import PurchaseButton\nimport './App.css';\n\nfunction App() {\n  // Define NFT Price and Token Details\n  const nftPrice = 100; // The price of the NFT in CRAFT tokens\n  const craftTokenMintAddress = \"YOUR_CRAFT_TOKEN_MINT_ADDRESS\"; // Replace with the actual mint address\n  const craftTokenDecimals = 9; // Replace with the actual number of decimals for the CRAFT token\n\n\n  // State to hold the NFT data after a successful purchase\n  const [purchasedNft, setPurchasedNft] = React.useState(null);\n\n  // Callback function to handle a successful purchase\n  const handlePurchaseSuccess = (nftData) => {\n      setPurchasedNft(nftData); // Set NFT data upon successful purchase\n  };\n\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>NFT Purchase App</h1>\n        <WalletConnect />\n\n        {/*  Pass NFT details and purchase callback  */}\n        <PurchaseButton\n            amount={nftPrice}\n            craftTokenMintAddress={craftTokenMintAddress}\n            decimals={craftTokenDecimals}\n            onPurchaseSuccess={handlePurchaseSuccess}\n        />\n\n        {/* Conditionally render NFTDisplay based on purchase status */}\n        {purchasedNft ? (\n            <>\n                <h2>Congratulations on your purchase!</h2>\n                <NFTDisplay nft={purchasedNft} /> {/* Pass the purchased NFT data to NFTDisplay */}              \n            </>\n        ) : (\n            <NFTDisplay /> // Display the general NFT display without specific data\n        )}\n\n\n\n      </header>\n    </div>\n  );\n}\n\nexport default App;",
  "nft-purchase-app/frontend/src/components/WalletConnect.js": "// frontend/src/components/WalletConnect.js\nimport React, { useCallback, useMemo } from 'react';\nimport {\n    ConnectionProvider,\n    WalletProvider,\n} from '@solana/wallet-adapter-react';\nimport { WalletAdapterNetwork } from '@solana/wallet-adapter-base';\nimport {\n    PhantomWalletAdapter,\n    SolflareWalletAdapter\n} from '@solana/wallet-adapter-wallets';\nimport {\n    WalletModalProvider,\n    WalletDisconnectButton,\n    WalletMultiButton\n} from '@solana/wallet-adapter-react-ui';\nimport { clusterApiUrl } from '@solana/web3.js';\n\n// Default styles that can be overridden by your app\nrequire('@solana/wallet-adapter-react-ui/styles.css');\n\nconst WalletConnect = () => {\n    // The network can be set to 'devnet', 'testnet', or 'mainnet-beta'.\n    const network = WalletAdapterNetwork.Devnet;\n\n    // You can also provide a custom RPC endpoint.\n    const endpoint = useMemo(() => clusterApiUrl(network), [network]);\n\n    // Wallets\n    const wallets = useMemo(() => [\n        new PhantomWalletAdapter(),\n        new SolflareWalletAdapter({ network }),\n    ], [network]);\n\n    return (\n        <ConnectionProvider endpoint={endpoint}>\n            <WalletProvider wallets={wallets} autoConnect>\n                <WalletModalProvider>\n                    <WalletMultiButton />\n                    <WalletDisconnectButton />\n                </WalletModalProvider>\n            </WalletProvider>\n        </ConnectionProvider>\n    );\n};\n\nexport default WalletConnect;",
  "nft-purchase-app/frontend/src/components/NFTDisplay.js": "// frontend/src/components/NFTDisplay.js\nimport React, { useState, useEffect } from 'react';\nimport axios from 'axios';\nimport { useWallet } from '@solana/wallet-adapter-react';\n\nconst NFTDisplay = ({ nft }) => {  // Receive nft prop\n    const { publicKey } = useWallet();\n    const [nfts, setNfts] = useState([]);\n    const [loading, setLoading] = useState(true);\n    const [error, setError] = useState(null);\n\n    useEffect(() => {\n        const fetchNFTs = async () => {\n            if (publicKey) {\n                try {\n                    const response = await axios.get(`/get_nfts/${publicKey.toString()}`); //Adjust URL - Change this to your backend url\n                    setNfts(response.data);\n                    setError(null);\n                } catch (err) {\n                    console.error(\"Error fetching NFTs:\", err);\n                    setError(err.message || \"Failed to fetch NFTs\");\n                    setNfts([]);\n                } finally {\n                    setLoading(false);\n                }\n            } else {\n                setLoading(false);\n                setNfts([]);\n                setError(null);\n            }\n        };\n\n        // Only fetch NFTs if nft prop is not provided\n        if (!nft) {\n            fetchNFTs();\n        } else {\n            // If nft prop is provided, use it to display the NFT immediately\n            setNfts([nft]); //Set it as a single element array\n            setLoading(false);\n        }\n    }, [publicKey, nft]); // Add `nft` to the dependency array\n\n    if (loading) {\n        return <div>Loading NFTs...</div>;\n    }\n\n    if (error) {\n        return <div style={{ color: 'red' }}>Error: {error}</div>;\n    }\n\n    if (!publicKey) {\n        return <div>Connect your wallet to view your NFTs.</div>;\n    }\n\n    return (\n        <div>\n            <h2>Your NFTs</h2>\n            {nfts.length === 0 ? (\n                <div>No NFTs found in your wallet.</div>\n            ) : (\n                <ul>\n                    {nfts.map((nft) => (\n                        <li key={nft.nft_id}>\n                            <h3>{nft.metadata_url ? 'NFT Metadata' : 'Missing Metadata'}</h3>\n                            {nft.metadata_url ? (\n                                <>\n                                    <a href={nft.metadata_url} target=\"_blank\" rel=\"noopener noreferrer\">\n                                        View NFT Metadata\n                                    </a>\n                                </>)\n                             : (\n\n                                <p>Metadata not available.</p>\n                            )}\n                               {/* Display NFT Image if available */}\n                               {nft.image && (\n                                   <img src={nft.image} alt=\"NFT Image\" style={{maxWidth: \'200px\'}} />\n                               )}\n                        </li>\n                    ))}\n                </ul>\n            )}\n        </div>\n    );\n};\n\nexport default NFTDisplay;",
  "nft-purchase-app/frontend/src/components/PurchaseButton.js": "// frontend/src/components/PurchaseButton.js\nimport React, { useState } from 'react';\nimport { useWallet } from '@solana/wallet-adapter-react';\nimport { PublicKey, Transaction } from '@solana/web3.js';\nimport axios from 'axios';\nimport { connection } from '../utils/solana'; // Import the connection\nimport { TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID, getOrCreateAssociatedTokenAccount, createTransferInstruction } from '@solana/spl-token';\n\nconst PurchaseButton = ({ amount, craftTokenMintAddress, decimals,  onPurchaseSuccess }) => { //amount in CRAFT\n    const { publicKey, sendTransaction } = useWallet();\n    const [isPurchasing, setIsPurchasing] = useState(false);\n    const [errorMessage, setErrorMessage] = useState(null);\n\n    // Replace with your recipient (admin) public key\n    const RECIPIENT_PUBLIC_KEY = \"YOUR_RECIPIENT_PUBLIC_KEY\";\n\n    const handlePurchase = async () => {\n        setIsPurchasing(true);\n        setErrorMessage(null);\n\n        if (!publicKey) {\n            setErrorMessage(\"Wallet not connected.\");\n            setIsPurchasing(false);\n            return;\n        }\n\n        if (!craftTokenMintAddress || craftTokenMintAddress === \"YOUR_CRAFT_TOKEN_MINT_ADDRESS\") {\n            setErrorMessage(\"CRAFT token mint address is not configured. Please set it in App.js\");\n            setIsPurchasing(false);\n            return;\n        }\n\n        if (!RECIPIENT_PUBLIC_KEY || RECIPIENT_PUBLIC_KEY ===  \"YOUR_RECIPIENT_PUBLIC_KEY\") {\n            setErrorMessage(\"Recipient public key is not configured. Please set it in PurchaseButton.js\");\n            setIsPurchasing(false);\n            return;\n        }\n\n\n        try {\n            // 1. Get associated token accounts for both the purchaser and the recipient\n            const purchaserAssociatedTokenAccount = await getOrCreateAssociatedTokenAccount(\n                connection,                // connection\n                publicKey,                   // payer (fee payer)\n                new PublicKey(craftTokenMintAddress),  // mint\n                publicKey                    // owner\n            );\n                // Ensure recipient public key is valid\n            const recipientPublicKey = new PublicKey(RECIPIENT_PUBLIC_KEY);\n\n            const recipientAssociatedTokenAccount = await getOrCreateAssociatedTokenAccount(\n                connection,                // connection\n                publicKey,                   // payer (fee payer)\n                new PublicKey(craftTokenMintAddress),  // mint\n                recipientPublicKey,                    // owner - VERY IMPORTANT:  Use recipient's wallet.\n            );\n\n             // 2. Calculate the amount to transfer (in token units)\n            const amountInTokenUnits = amount * (10 ** decimals); // Assuming you have 'decimals' available\n\n            // 3. Create the transfer instruction\n            const transferInstruction = createTransferInstruction(\n                purchaserAssociatedTokenAccount.address, // source\n                recipientAssociatedTokenAccount.address,   // destination\n                publicKey,                                  // owner/authority (signer)\n                amountInTokenUnits,                         // amount\n                [],                                         // multiSigners (optional)\n                TOKEN_PROGRAM_ID                             // The SPL Token Program ID\n            );\n\n            const transaction = new Transaction().add(transferInstruction);\n            transaction.feePayer = publicKey;\n            transaction.recentBlockhash = (await connection.getLatestBlockhash()).blockhash;\n\n            const signature = await sendTransaction(transaction, connection);\n\n            //Call backend to verify the transaction\n             const response = await axios.post('/verify_payment', { //Adjust URL - Change this to backend url\n                 transactionSignature: signature,\n                 userPublicKey: publicKey.toString(),\n                 amount: amount,\n                 craftTokenMintAddress: craftTokenMintAddress\n             });\n\n            if (response.data.success) {\n                onPurchaseSuccess(response.data.nft_data); //Pass NFT data to parent component\n            } else {\n                setErrorMessage(response.data.error || \"Payment verification failed.\");\n            }\n\n\n            setIsPurchasing(false);\n\n        } catch (error) {\n            console.error(\"Purchase error:\", error);\n            setErrorMessage(error.message || \"An error occurred during purchase.\");\n            setIsPurchasing(false);\n        }\n\n    };\n\n    return (\n        <div>\n            <button onClick={handlePurchase} disabled={isPurchasing}>\n                {isPurchasing ? (isPurchasing ? "Purchasing..." : `Purchase NFT (${amount} CRAFT)`): `Purchase NFT (${amount} CRAFT)`}\n            </button>\n            {errorMessage && <div style={{ color: 'red' }}>Error: {errorMessage}</div>}\n        </div>\n    );\n};\n\nexport default PurchaseButton;",
  "nft-purchase-app/frontend/src/utils/solana.js": "//Used for connection on the PurchaseButton.js\nimport { clusterApiUrl, Connection } from '@solana/web3.js';\n\n//The solana network you want to connect to\nconst network = clusterApiUrl(\"devnet\");\n\n//Creating the connection to the Solana network\nexport const connection = new Connection(network);",
  "nft-purchase-app/frontend/src/App.css": "/* frontend/src/App.css */\n.App {\n  text-align: center;\n}\n\n.App-header {\n  background-color: #Okay, I understand. I'm ready to analyze the history, code, proposed improvements, and new request to deliver the updated code while adhering to your stringent constraints. I will return the complete project structure with the updated code for each file, along with an explanation of the modifications. Let's begin.

I'm awaiting the following information:

1.  **Previous prompts:** All the prompts leading to the creation of the existing code.
2.  **Existing Code:** The complete code you want me to update.
3.  **Project Structure:** A JSON representation of the project's file and directory structure with corresponding code.
4.  **Code Explanation, Proposed Improvements, and Caveats:** Details about the current code, proposed improvements, and any identified caveats/issues.
5.  **New User Request:** The specific changes/improvements the user wants.

Once I receive this, I will meticulously apply the requested changes, preserve the existing structure, and address any identified caveats. I will then provide the complete, updated project structure with code.
